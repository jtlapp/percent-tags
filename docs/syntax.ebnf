
Body ::= ST* BodyLine? (NL ST* BodyLine?)* /*possibly empty*/
BodyLine ::= IF('```', CodeBlock, IF('%', TaggedLine, UntaggedLine))

CodeBlock ::= '```' ST? (CodeLang ST?)? NL Code? '```'
Code ::= IFNOT('```', PrintableChar | STN)+

TaggedLine ::= '%' TagSpec (ST+ (InlineValues | InlineTaggedElem)) ST*
TagSpec ::= TagName ('.' TagName)?
InlineValues ::= Bracketed ((ST+ Bracketed)+ | (ST* ',' STN* Bracketed)+)?
InlineTaggedElem ::= InlineTags (ST* ':' ST* EndLineContent)?

TagName ::= SimpleTagName | QuotedTagName
SimpleTagName ::= [A-Za-z_][A-Za-z0-9_]*
QuotedTagName ::= '"' QuotedChar+ (S QuotedChar+)* '"'

InlineTags ::= InlineTag (ST+ InlineTag)*
InlineTag ::= TagName Bracketed?
EndLineContent ::= IF('[', InlineValues, UntaggedLine)

UntaggedLine ::= (Bounded Unbracketed)+ | Unbracketed (Bounded Unbracketed?)*
Unbracketed ::= (BodyChar Literal?)+ | Literal (BodyChar Literal?)*
BodyChar ::= InlineChar - Bracket | EscapedChar | ST

Bounded ::= Bracketed | Braced | Parenthesized
Bracketed :: = '[' Body ']'
Braced ::= '{' Body '}'
Parenthesized ::= '(' Body ')'

Literal ::= DoubleLiteral | SingleLiteral
DoubleLiteral ::= '``' LiteralChar+ ('`' LiteralChar+)* '``'
SingleLiteral ::= '`' LiteralChar+ '`'
LiteralChar ::= InlineChar | EscapedChar | S
EscapedChar ::= '\' PrintableChar

PrintableChar ::= UnicodeChar - ControlChar - S
ControlChar ::= [#x00-#x1F] | #x7f
InlineChar ::= PrintableChar - '`' - '\'
QuotedChar ::= PrintableChar - '"' - '\' | EscapedChar

Bracket ::= LeftBracket | RightBracket
LeftBracket ::= '{' | '[' | '('
RightBracket ::= '}' | ']' | ')'
S ::= #x20
Tab ::= #x09
CR ::= #x0D
LF ::= #x0A
NL ::= CR? LF
ST ::= S | Tab
STN ::= S | Tab | NL

* IF(ifThis, thenMatchThis, elseMatchThis) - reduces complexity of BNF
* IFNOT(ifNotThis, thenMatchThis)
* X(Y) - Generates a production rule with Y expanded in X

TBD: IDs/refs
TBD: nested lists
TBD: generalize ` notation to swallow whatever's between the delims

----

Objectives:

* annotate code within comments (it's a code annotation language)
* metadata within formatted text
* parse parameters in a consistent way
* simple data structures providing English description or metadata
* Within the data annotations, able to provide formatted text

Non-objectives:

* representing arbitrary data structures
* formatting text or marking up text with formatting
* not a syntax for comments; instead, a syntax for embedding metadata in comments and a syntax for the metadata structure

Questions:

* Metadata is data requiring structure, which could potentially be arbitrary. What structures do I really need to support?
* Data parsed from this syntax can be handed to an app for app-specific parsing. When should the parsing structure be universal, when app-specific?