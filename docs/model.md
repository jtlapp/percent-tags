
# CherryTags Information Model

The CherryTags model is a model for associating human-centric metadata with text.

## Summary

This is a metamodel.

TBD: restricted to content annotation; metadata characterizes content
TBD: Change model to metamodel everywhere? Because there's also a syntactic model? Or call it the information model?

## Objectives and Non-Objectives

The CherryTags model was developed to provide an information model for directives embedded in source code comments. The model has been abstracted to be independent of both its syntactic representation and the nature of the text that the directives characterize. It abides by the following guiding principle:

> Assume that the data is generated by humans, for humans, or both by and for humans.

In particular, the model strives to meet the following objectives:

* Provide a consistent data model for metadata about text, particularly about source code.
* Allow metadata to have internal structure for mirroring the software data structures they describe.
* Facilitate simple syntactic representation by minimizing type complexity.
* Unify primitive constructs that conventionally represent the same information, in order to reduce ambiguity and human error in writing and reading source code metadata.
* Keep the model as simple as possible to minimize the effort required to learn and understand it.

The following are explicitly non-objectives of the model:

* Don't strive to generically support arbitrary ontologies; characterization is by tagging only.
* Don't strive to generically represent serialized data. Metadata is deemed to be primarily data generated by humans for human consumption.
* Don't support the panopoly of primitive types, which vary greatly by programming language. This helps the syntactic representation of the model be independent of programming language.
* Don't model text formatting and markup; leave that to a client model and ambient syntax.

## Content and Metadata

The model separately represents information as content and metadata. Content is the primary information of the structure. Metadata is information that further characterizes the content. Within this model, all data is fundamentally text.

For example, the text of a document would be its content and primary information, while attributes such as the title, author, and font to use for rendering would all be metadata. Moreover, the values of these attributes would be expressed as text.

It is possible for a structure to have no content, indicating that it has no primary information. When this structure has metadata, the metadata is all equally primary. An address consisting of metadata for street, city, state/province, postal code, and country would be an example of a structure having metadata but no content.

It is also possible for a structure to have neither metadata nor content, indicating an absence of data. This structure explicitly asserts that no data is available.

Metadata may itself be structured, itself having either content or metadata or both. For example, metadata for a to-do list could be a structured list of items. Each to-do item includes text that could itself serve as content for nested 'priority', 'due date', or 'done' metadata indicators.

## Elements and Tags

In the CherryTags model, the structures that hold content and metadata are called *elements*, while *tags* are the means for attaching metadata to elements.

An 'element' is the fundamental unit of information. It represents either content or the absence of content. An element's content may be a list of other elements, such as a list of elements representing authors, to-do items, or function parameters.

A 'tag' is an association of an element with a name and a value. The name is a short, readable string, and the value is another element. To 'tag' an element is to associate the element with a tag name and value.

Tags are useful for assigning application-specific properties to an element. Consider a file having a property given by the tag name "company" or "contact". The value of the "company" tag would be an element providing the text of the company name, while the value of the "contact" tag would be an element that itself has property tags for each of name, email, and phone number.

Tags are also useful for assigning application-specific types to an element without also associating more content with the element. Consider an element that represents an excerpt or one that represents a citation. In the former case the content of the element might be excerpted text, and in the latter case it might be an element tagged with "book", "author", and "publication" tags. In both cases the tagged element already provides the required content, so the tag need only provide the type name, without also providing a value.

Together, elements and tags can characterize textual content with software-readable structures that are labelled for human consumption.

## Element Types

Elements vary in the structure of their content. Each has an inherent type that identifies its structure. Accordingly, any given element is a *literal*, a *list*, or an *empty element*.

### Literals

A 'literal' is an element whose content corresponds to an ordered series of one or more Unicode characters. Literals are the fundamental units of the information model and are intended to represent human-generated, human-readable content. Any given literal is either a *text element* or a *number element*.

A 'number' element represents an integer or floating point number. A number element cannot represent [NaN](https://en.wikipedia.org/wiki/NaN), [signed infinities](https://en.wikipedia.org/wiki/IEEE_754-1985#Positive_and_negative_infinity), or [signed zeros](https://en.wikipedia.org/wiki/Signed_zero).

A 'text element' represents any string of characters that doesn't represent a number. Even so, the content of a text element may be a string of characters that happens to correspond to a number, such as an unpunctuated phone number or an ID that might sometimes contain letters.

Notice that a text element cannot represent an empty string. In this model, all occurrences of the absence of data are equivalently represented as an empty element. 

No other primitive types are supported, because numbers and strings appear to be universal and other types are easily represented in terms of them. A client application that requires booleans, symbols, regular expressions, dates, etc., would have to define these types in terms of text and number elements. 

### Lists

A 'list' is an element representing a collection of independently-intelligible units of information. Its content is an ordered series of two or more elements, each of which is called a 'member' of the list. The client application determines whether the order in which members appear is meaningful.

Examples of lists include a checklist of to-do items, a series of log entries, a series of structured records, and the columns at which to place tab stops.

Notice that a list cannot be empty. In this model, an empty set is equivalent to the absence of data, which are both represented as an empty element.

Also notice that a list cannot have just one element. This model does not represent collections independently of the elements composing the collections.

### Empty Elements

An 'empty element' is an element representing the absence of primary information. It has no content. An untagged occurrence indicates the complete absence of data. A tagged occurrence indicates a structured record having only properties and types, in any combination, but no immediate content.

Examples of empty elements include the value of a tag that only indicates type, a placeholder within a list, an address consisting of address fields, and a specification for a configuration consisting only of properties.

Nothing inherently distinguishes the meaning of a tagged empty element from that of an element containing content. Their only difference is structure. Whether data occurs within a tag value or within content is a characteristic of the schema of tags employed to structure the text.

## Tags

*Tags* are the means for semantically labeling data in the CherryTags model. Tags can be organized into *schemas* that define a set of related tag types, their valid values, and their interpretations.

### Tag Associations

A *tag* is formally an association of an element with a *tag type* and a *tag value*. The association assigns a type or a property to the element, according to the tag type/tag value combination.

A tag association may be called a "tagging". The tag type is said to 'tag' the element, and the element is said to be 'tagged'. An element not participating in any tag associations is said to be 'untagged'.

An element may participate in any number of tag associations, but it participates in at most one association with any given tag type. When an element participates in multiple tag associations, the associations are unordered relative to one another.

The 'tag value' is itself an element. It may even be a tagged element. Moreover, a given element may be the value of multiple different tags, allowing values to form arbitrary directed graphs.

When the tag value is a literal, a list, or a tagged empty element, the tag serves as a property assignment on the tagged element, with the tag value being the value of the property. When the tag value is an untagged empty element, the tag instead serves as a type assignment unless the tag type also allows other values.

### Tag Types

The 'tag type' of a tagging provides the meaning of the tag and uniquely distinguishes it from all other tags. Any given tag type may participate in any number of taggings of any number of elements. Each tag type has a *tag name* and a *namespace*.

The 'tag name' is a name that is descriptive or suggestive of the tag type, at least within the context of the namespace. It is a character string conforming to the `TagName` production as defined the following modified EBNF<sup>[1](#note_1)</sup>:

```ebnf
TagName ::= InitialTagNameChar TrailingTagNameChar*;
InitialTagNameChar ::= '$' | '_' | UnicodeIDStart;
TrailingTagNameChar ::= '$' | '_' | UnicodeIDContinue | UnicodeZWJ | UnicodeZWNJ;
UnicodeIDStart ::= ? any Unicode character with property 'ID_Start' ?;
UnicodeIDContinue ::= ? any Unicode character with property 'ID_Continue' ?;
UnicodeZWJ ::= \u200C;
UnicodeZWNJ ::= \u200D;
```

According to [ECMAScript 2019](https://tc39.github.io/ecma262/#sec-names-and-keywords), the above `TagName` production matches the set of valid Javascript identifiers. [Unicode Standard Annex #31](https://unicode.org/reports/tr31/) specifies the Unicode characters having the properties 'ID_Start' and 'ID_Continue'. Note that the 'ID_Start' characters are also 'ID_Continue' characters and include the uppercase and lowercase ASCII letters. Also note that the 'ID_Continue' characters include ASCII digits `0` through `9`.

The 'namespace' is a scope of one or more tag types, each of which is called a 'member' of the namespace. Namespaces are structurally analogous to a Universal Resource Locators (URLs), minus the URL protocol or scheme. Each namespace has a domain name and is identified relative to this domain name via a series of tag names. Specifically, any given namespace is either a tag type or a *domain*.

A 'domain' is an Internet domain corresponding to a domain name. The domain name is a string of Unicode characters conforming to [IETF RFC 3490](https://tools.ietf.org/html/rfc3490) and including at least one subdomain below the top-level domain.

A namespace that is a tag type itself has a namespace, which is either a domain or another tag type. Namespaces may therefore be organized hierarchically, with a domain at the root of each hierarchy, and with each member of a namespace being an immediate child of the namespace in the hierarchy.

Within a given namespace, tag names that differ only in letter case refer to the same tag type.

### Tag Schemas

Given that a tag name and namespace together uniquely identify a tag type among all possible tag types, it is possible to define tag types independently of their applications. These definitions are *tag schemas*. A 'tag schema' is a specification of a set of tag types, of the values that are valid for each tag type, and of the interpretations that applications should give the tag types and tag values.

A schema may organize its tag types into namespaces. In the CherryTags model, a namespace is technically a tag type, so the schema may define what it means to tag an element with a namespace. One particularly useful technique defines the namespace as a property and the tag types in the namespace as parameters that characterize the property. This is analogous to defining a structured type in a programming language, allowing a schema to define macroscopic properties having property-specific configuration options.

Consider an example of tagging an element with a namespace called `Contact`. Assume that the members of this namespace are tag types named `FirstName`, `LastName`, `Email`, and `PostalAddress`. One could tag an element with the tag type `Contact`, assigning an empty element tag value, and further tag this empty element with the aforementioned members. The `PostalAddress` tag type could also be a namespace for further nested tag types such as `Street`, `StateOrProvince`, `PostalCode`, and 'Country`.

As a final note, when designing schemas it's important to keep CherryTags' guiding principle in mind: that the information model is for human-generated data or human-consumed data or both but not for data both software-generated and software-consumed. The model is expected to evolve consistent with this principle, particularly to address challenges that arise from striving to create such schemas.

## Notes

<a name="note_1"><sup>1</sup></a> The EBNF excludes commas by employing the following operator precedence, highest-precedence first: `*`, ` ` (space), `|`, and `::=`. It also specifies Unicode characters via the `\u` escape sequence, which ends in the four-digit hex representation of the Unicode code point.

TBD: references to specs should be footnotes


%

- owl eyes / owlies (but unclear pronunciation) / owlees
- bird eyes
- pong
- cufflinks
- potoo (hard to remember)
- bubbles
- berries
- berry tags
- boggle eyes
- revolving door
- merry go round
- turnstile (taken in NPM)
- lifesaver
- mints
- stork
- pinball
- paddle (paddle tags)
- cherry tags
- modmods/moddocs

